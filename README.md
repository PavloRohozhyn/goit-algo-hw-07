### Завдання 1 ([task1.py](task1.py))

Напишіть алгоритм (функцію), який знаходить найбільше значення у двійковому дереві пошуку або в AVL-дереві. Візьміть будь-яку реалізацію дерева з конспекту чи з іншого джерела.


### Завдання 2 ([task2.py](task2.py))

Напишіть алгоритм (функцію), який знаходить найменше значення у двійковому дереві пошуку або в AVL-дереві. Візьміть будь-яку реалізацію дерева з конспекту чи з іншого джерела.


### Завдання 3 ([task3.py](task3.py))

Напишіть алгоритм (функцію), який знаходить суму всіх значень у двійковому дереві пошуку або в AVL-дереві. Візьміть будь-яку реалізацію дерева з конспекту чи з іншого джерела.


### Розвязки

 - <b>Node:</b> Клас, що представляє вузол дерева. Кожен вузол має значення (key), ліву та праву дитину. Також інтегровано функцію <b>display</b> для візуалізації.
 - <b>insert:</b> функція для вставки нових значень у дерево.
 - <b>find_max_value:</b> Функція для знаходження найбільшого значення. Вона просто проходить по правих дочірніх вузлах, поки не знайде найбільш правий вузол.
 - <b>find_min_value:</b> Функція для знаходження найменшого значення в дереві. Вона спускається по лівих дочірніх вузлах до найменшого.
 - <b>sum_tree:</b> Рекурсивна функція для обчислення суми всіх значень дерева. Якщо вузол порожній (None), вона повертає 0. Інакше додає значення поточного вузла та рекурсивно.


![task1_result](task1_result.png "task1_result")

 - Ми спускаємось від кореня по правих дочірніх вузлах, тому що вони завжди більші за батьківські.
 - Коли досягнемо вузла без правої дитини, його значення і буде найбільшим у дереві.
 - Цей підхід працює як для звичайного двійкового дерева пошуку, так і для AVL-дерева, оскільки балансування в AVL-дереві не впливає на пошук максимального значення.

![task2_result](task2_result.png "task2_result")

 - Починаємо з кореня дерева.
 - Спускаємось по лівих дочірніх вузлах, оскільки вони завжди менші за батьківські.
 - Коли досягнемо вузла без лівої дитини, його значення і буде найменшим у дереві.

![task3_result](task3_result.png "task3_result")

 - Якщо вузол порожній, повертаємо 0.
 - Рекурсивно обчислюємо суму для лівого та правого піддерев.
 - Додаємо значення поточного вузла до суми обох піддерев.

Ці всі підходи підходять як для звичайного двійкового дерева пошуку, так і для AVL-дерева, оскільки балансування в AVL-дереві не змінює пошук найменшого, найбільшого значення чи обрахунку суми усіх вузлів.

